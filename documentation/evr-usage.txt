
/////////
Compile with asciidoc
http://www.methods.co.nz/asciidoc/
/////////

MRF EVR Usage Guide
===================
:Author:    Michael Davidsaver
:Email:     mdavidsaver@bnl.gov
:Date:      May 2010
:Revision:  2
:Key words: epics, ioc, device support, mrf, timing

== Overview ==

The purpose of this document is to act as a guide and reference
when using the 'mrfioc2' EPICS device support for the Micro Research
Finland (MRF) timing Event Receiver (EVR).
Usage of the Event Generator (EVG) is described elsewhere.

The MRF Event Timing System can be deployed in two configurations.
The first is a unidirectional broadcast from a single source (EVG) to multiple
destinations (EVRs).
The Repeater devices are simply retransmits the its single input to all outputs.
In the second configuration a return patch from many EVRs back up to a central
(master) EVR is added.

An EVR will act in one of two roles: either Leaf or Master.
All, or all but one, EVR will be in the Leaf role.
The special Master EVR acts as the termination point for events
and data on the upstream path.

The Master EVR is necessary because, while the generator (EVG) is capable of
receiving an event stream, it does not impliment most of the features of the
receiver (EVR).

[[mrf_overview]]
.Two system configurations for the MRF Timing System
image::images/mrf-overview.png[]

What is transmitted over the event link is a combination of 8-bit event
codes and data.
Data can take the form of a single 8-bit byte which is simply copied from sender
to receiver (Distributed Bus or DBus), and optionally a variable length byte
array (Data Buffer).

These two types of data can be combined in two ways depending on whether or not
the data buffer transmission feature is used.
In configuration A every 16-bit frame is split between an 8-bit event and
the 8-bit Distributed Bus.
In configuration B every frame carries an 8-bit event with the Distributed Bus
and Data Buffer sent in alternating frames.

In addition to data, the use of 8b10b encoding on the event link allows the
local oscillator of each EVR to be phase locked to the master on the EVG.

[[mrf_frames]]
.Two supported link allocation schemes
image::images/mrf-frames.png[]

Internally an EVR can be thought of a number of logical sub-units connected
to the up- and down- stream event links, and to the local inputs and outputs
of the EVR.
These sub-units include: the Event Mapping Ram, Pulse Generators,
Prescalers (clock dividers), and the logical controls for the physical
inputs and outputs.

[[evr_blocks]]
.Logical connections inside an EVR
image::images/mrf-evr-blocks.png[]

=== Pulse Generators ===

Each pulse generator has a an associated delay, width, polarity
(active low/high), and (sometimes) a prescaler (clock divider).
When triggered by the Mapping Ram it will wait for a set time in its inactive state (delay).
Then it will transition to its active state, wait another set time (width)
before transitioning back to its inactive state.

In addition, the Mapping Ram can force a Pulse Generator into either state (Set/Reset).

Note: Some Pulse Generators do not have a prescaler.  In this case the prescaler
      property will always read 0 instead of >=1.

=== Event Mapping Ram ===

The Event Mapping Ram is a table used to define the actions to be taken by
an EVR when it receives a certain event code number.
The mapping it defines is a many-to-many relations.
One event can cause several actions, and one action can be caused by
several events.

The actions which can be taken can be grouped into two catagories:
Special actions, and Pulse Generator actions.
Special actions include those related to timestamp distribution, and
the system heartbeat tick.
Each Pulse Generater has three mapable actions: Set (force active), Reset (force inactive), and Trigger (start delay program).  Most applications will use Trigger
mappings.

=== Prescalers (Clock Divider) ===

Prescaler sub-units take the local system clock frequency and output a
lower frequency clock which is phased locked to the local clock,
which is in sync with the global master clock.
The lower frequency will be an integer divisor of the system clock.

=== Outputs (TTL) ===

This sub-unit represents a local physical output on the EVR.
Each output may be connected to one source: a Distributed Bus bit,
a Prescaler, or a Pulse Generator.


=== Outputs (CML) ===

Current Mode Logic outputs can send a bit pattern at the bit rate of the event link (20x the Event Clock).
This pattern may be specified in one of three possible ways.

# As four 20 bit sub-patterns (rising, high, falling, and low).  The rising and falling patterns are transmitted when the output level changes, while the high and low patterns are repeated until the level changes.
# As two times (high and low).  These specify a square wave with variable frequency and duty factor.
# As an arbitrary bit pattern (<= 40940 bits) which begins when the output goes [TODO: high or low?].

=== Inputs ===

An input can cause several actions when triggered by a local signal.
It may be directly connected to one of the upstream Distributed Bus bits,
it may cause an event to be sent on the upstream links, or applied
to the local Mapping Ram.

=== Global Timestamp Reception ===

Each EVR receives synchronous time broadcasts from an EVG.
The driver may query the current time at any point.
The arrival time of certain event codes can be saved as well.
This can be accomplished with the 'event' record device support.

=== Data Buffer Tx/Rx ===

When the event system is configured to share the data byte of each frame EVR can receive
data broadcasts from an EVG and/or send data back to the master EVR.
Each data block has a one byte header (Protocol ID) used to identify interested recipients.

Recipients will register callback functions.

The default recipient stores data in a waveform record.

== What is Available? ==

More infomation on the Micro Research hardware can be found on their
website http://www.mrf.fi/[http://www.mrf.fi/].

The software discussed below can be found on the EPICS application
project on SourceForge http://sourceforge.net/projects/epics/[http://sourceforge.net/projects/epics/].

The latest developments can be found in the 'mrfioc2' Mercuial VCS repository.

http://epics.hg.sourceforge.net/hgweb/epics/mrfioc2/summary[http://epics.hg.sourceforge.net/hgweb/epics/mrfioc2/summary]

=== Prerequisites ===

Requires EPICS Base (>= 3.14.8.2), and the MSI tool.  Supported on RTEMS >= 4.9.x, vxWorks >=6.7, and Linux >= 2.6.26.

Base: http://www.aps.anl.gov/epics/base/R3-14/index.php[http://www.aps.anl.gov/epics/base/R3-14/index.php]

MSI: http://www.aps.anl.gov/epics/extensions/msi/index.php[http://www.aps.anl.gov/epics/extensions/msi/index.php]

The Mercurial VCS tool is needed to checkout the development repository.

Mercuial: http://mercurial.selenic.com/[http://mercurial.selenic.com/]

=== The Source ===

VCS Checkout

-----------------------------------------------------------------------
$ hg checkout http://epics.hg.sourceforge.net:8000/hgroot/epics/mrfioc2
-----------------------------------------------------------------------

Edit 'configure/CONFIG_SITE' and run "make".

The following is a brief tour of the important locations in the source tree
relating to the EVR.

==== mrfCommon ====

Some support functions.  Contains 'mrfCommonIO.h' which devices macros
for access to memory mapped IO.  Also the support a library and CLI utilities
for en/decoding the control word for the fractional synthesizer used on
EVRs and EVGs.

==== pciApp ====

OS independent abstraction for working with PCI devices.

==== vmeApp ====

OS independent abstraction for working with VME64x devices.

==== mrmShared ====

Contains code shared with the EVG.
This includes data buffer transmission.

Also contains the Linux kernel driver stub to allow userspace PCI operations.

==== evrApp ====

The MRF IOC has a strong seperation between device and driver support.
The device support and interface definition are in this module.
The interface is defined by the C++ abstract base classes in 
'evrApp/src/evr/'.
A set of device support routines using is found in 'evrApp/src/dev*.cpp'.
Some generic database files are found in 'evrApp/Db/'.

==== evrMrmApp ====

The is the driver for the Modular Register Map (MRM) firmware
version for the EVR.
It provides a concrete implimentation of the abstract classes defined
in 'evrApp'.
It also provided IOC shell functions to instanciate a device in
'evrMrmApp/src/drvemIocsh.cpp'.
'evrMrmApp/Db/evr-*.substitutions' will create a complete example
database.
An example IOC using the database is in 'iocBoot/iocevrmrm/'.

== Supported Hardware ==

The following devices are supported.

=== VME EVR 230 (non-RF) ===

Outputs: Front panel: 4, Front Panel UNIV. 2
Inputs: Front panel: 2

Support the VME rear transition module.

=== VME EVR 230 (RF) ===

This device has like the non-RF version, but front panel outputs 4, 5, and 6
are CML outputs.

DB template: evr-vmerf-230.substitiutions

=== PMC EVR 230 ===

A PCI Mezzanine Card with one front panel input and two front panel outputs.

Outputs: Front panel: 2
Inputs: Front panel: 1

DB template: evr-pmc-230.substitiutions

=== cPCI EVR 230 ===

A compact PCI Card.

Outputs: Front panel universal: 4
Inputs: Front panel: 2

DB template: evr-cpci-230.substitiutions

== Device Support Design ==

The EPICS device support package for EVRs consists of a number of supports
which are generally tied to a specific logical sub-unit.
Each sub-unit may be thought of as having a number of properties.
For example a Delay Generator has properties 'Delay' and 'Width'.
These properties can be set in several ways.
A delay can specified as an integer number of ticks of its reference
clock (hardware view), or in seconds as a floating point number (user view).

In this example the properties 'Delay' and 'Width' should be settable in
exact integer as well as the more useful, but inexact, units of seconds.
This needs to be accomplish by two different device supports (longout,
and ao).
Of course it is also useful to have some confirmation that settings
have been applied so read-backs are desireable (longin, ai).

To this end the Pulser impliments the following device supports.

-------------------------------------------------------
# Pulser devices
# '@C=cardid, I=pulserid, P=property'
device(longin,     INST_IO, devLIPulser, "EVR Pulser")
device(longout,    INST_IO, devLOPulser, "EVR Pulser")
device(ai,         INST_IO, devAIPulser, "EVR Pulser")
device(ao,         INST_IO, devAOPulser, "EVR Pulser")
device(bi,         INST_IO, devBIPulser, "EVR Pulser")
device(bo,         INST_IO, devBOPulser, "EVR Pulser")
-------------------------------------------------------

Since the Pulser sub-unit has the property 'Delay'
which supports both integer and float settings,
the following database can be constructed.

--------------------------------------------
record(ao, "$(P)$(N)delay:set") {
  field(DTYP, "EVR Pulser")
  field(OUT , "@C=$(C), I=$(PID), P=Delay")
  field(PINI, "YES")
  field(DESC, "Pulse Generator $(PID)")
  field(VAL , 0)
  field(EGU , "uSec")
  field(LINR, "LINEAR")
  field(ESLO, 1e6)
  field(PREC, 6)
  field(FLNK, "$(P)$(N)delay")
}

record(longout, "$(P)$(N)delay:set:raw") {
  field(DTYP, "EVR Pulser")
  field(OUT , "@C=$(C), I=$(PID), P=Delay")
  field(FLNK, "$(P)$(N)delay")
}

record(ai, "$(P)$(N)delay") {
  field(DTYP, "EVR Pulser")
  field(INP , "@C=$(C), I=$(PID), P=Delay")
  field(UDF , 0)
  field(EGU , "uSec")
  field(LINR, "LINEAR")
  field(ESLO, 1e6)
  field(PREC, 6)
  field(FLNK, "$(P)$(N)delay:raw")
}

record(longin, "$(P)$(N)delay:raw") {
  field(DTYP, "EVR Pulser")
  field(INP , "@C=$(C), I=$(PID), P=Delay")
}
--------------------------------------------

This provides "raw" and "cooked" setting and readback
for the delay property.

It is generally inadvisible to have both "raw" and "cooked"
settings in a production database unless steps are taken to
synchronize them.

== Device Support Reference ==

The following sections list the properties for all sub-units
with functional descriptions.

=== Global ===

Properties in this section apply to the EVR as a whole.

Records accessing properties in this section will have DTYP
set to "EVR".

See: evrApp/Db/evrbase.db

==== Enable ====

Implimented for: bo, bi

Master enable for the EVR.
If not set then very little will happen.

==== PLL Lock Status ====

Implimented for: bi

This indicates whether the phase locked loop which synchronizes
an EVR's local oscilator with the phase of the EVG's oscilator.

Except for immediately after a change to the fractional synthesizer
this should always read as true (locked).

==== Link Status ====

Implimented for: bi

Indicates that the event link is active.
This means that the receiver sees light, that the phase is locked,
and that valid data is being received from the EVG.

A reading of false may be caused by a number of conditions including:
EVG down, fiber unplugged or broken, and/or incorrent fractional synthesizer
setting.

==== Model ====

Implimented for: longin

The hardware model number.

==== Version ====

Implimented for: longin

The firmware version.

==== Clock ====

Implimented for: ao, ai

Frequency of an EVR's local oscilator.
This must be close enough to the EVG master oscilator
to allow the phase locked loop to lock.

The native analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.

==== Timestamp Source ====

Implimented for: longout, longin

Determines what causes the timestamp event counter to tick.
There are three possible values.

"Event clock" (0) uses an integer divisor of the EVR's local oscilator.

"Mapped code(s)" (1) increments the counter whenever certain events arrive.
These codes can be defined using special mapping records.

"DBus 4" uses increments on the 0->1 transition of DBus bit #4.

==== Timestamp Clock ====

Implimented for: ao, ai

Specifies the rate at which the timestamp event counter will be incremented.
This determines the resolution of all timestamps.

This setting is used in conjunction with the 'Timestamp Source'.

When the timestamp source is set to "Event clock" this property
is used to compute an integer divider from the EVR's local oscilator
frequency to the given frequency.  Since this may not be exact it is
possible to read back the actual divider setting via the
"Timestamp Prescaler" property.

In all modes this value is used to convert the timestamp event counter
values from ticks to seconds.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.

==== Timestamp Prescaler ====

Implimented for: longin

When using the "Event clock" timestamp source this will return the actual
divisor used.  In other modes it reads 0.

==== Timestamp ====

Implimented for: stringin

When processed creates a human readable string with either the current
event link time, or the event link time when code # was last received.

==== Event Clock TS Div ====

Implimented for: longin

This is an approximate divider from the event link frequency down to
1MHz.  It is used to determine the heartbeat timeout.

==== Receive Error Count ====

Implimented for: longin

Counts the number of event link errors which occur.



=== Pulse Generator ===

Properties in this section apply to the Pulse Generator (Pulser) sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Pulser".

See: evrApp/Db/evrpulser.db

==== Enable ====

Implimented for: bo, bi

When not set the output of the Pulse Generator will remain in its
inactive state (normally low).
It must be set before mapped actions will have any effect.

==== Polarity ====

Implimented for: bo, bi

Reverses the output polarity.
When set, changes the Pulse Generator's output from normally low
to normally high.

==== Prescaler ====

Implimented for: longout, longin

Increses the resolution of both delay and width by an integer multiple.
Determines the tick rate of the down counters used for delay and width
with respect to the EVR's local oscillator.

==== Delay ====

Implimented for: ao, longout, ai, longin

Determines the time between when the Pulse Generator is triggered
and when it changes state from inactive to active (normally low to high).

This can be given in integer ticks, or floating point seconds.
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e6 to allow user setting/reading in microseconds.

==== Width ====

Implimented for: ao, longout, ai, longin

Determines the time between when the Pulse Generator changes state
from inactive to active (normally low to high), and when it changes
back to inactive.

This can be given in integer ticks, or floating point seconds.
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e6 to allow user setting/reading in microseconds.



=== Prescaler (Clock Divider) ===

Properties in this section apply to the Prescaler sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Prescaler".

See: evrApp/Db/evrscale.db

==== Divide ====

Implimented for: longout, ao, longin

Sets the integer divisor between the Event Clock and the sub-unit output.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.



=== Output (TTL and CML) ===

Properties in this section apply to the Output sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Output".

See: evrMrmApp/Db/mrmevrout.db

==== Map ====

Implimented for: longout, longin

The meaning of this value is determined by the specific implimentation used.

For the MRM implimentation the following codes are valid.

[width="25%",cols="1,5",options="header"]
|=========================
|#  |Output Source
|63 |Force High
|62 |Force Low
|42 |Prescaler (Divider) 2
|41 |Prescaler (Divider) 1
|40 |Prescaler (Divider) 0
|39 |Distributed Bus Bit 7
|38 |Distributed Bus Bit 6
|37 |Distributed Bus Bit 5
|36 |Distributed Bus Bit 4
|35 |Distributed Bus Bit 3
|34 |Distributed Bus Bit 2
|33 |Distributed Bus Bit 1
|32 |Distributed Bus Bit 0
| 9 |Pulse generator 9
| 8 |Pulse generator 8
| 7 |Pulse generator 7
| 6 |Pulse generator 6
| 5 |Pulse generator 5
| 4 |Pulse generator 4
| 3 |Pulse generator 3
| 2 |Pulse generator 2
| 1 |Pulse generator 1
| 0 |Pulse generator 0
|=========================

=== Output (CML only) ===

Additional properties for CML outputs.

Records accessing properties in this section will have DTYP
set to "EVR CML" with the exception of waveform records which have either "EVR CML Pattern Set" or "EVR CML Pattern Get".

See: evrApp/Db/evrcml.db

==== Enable ====

Implimented for: bo, bi

Trigger permit.

==== Power ====

Implimented for: bo, bi

Current on.

==== Reset ====

Implimented for: bo, bi

Pattern reset.

==== Mode ====

Implimented for: mbbo

Selects CML pattern mode.  Possible values are: 4x Pattern (0), Frequency (1), Waveform (2).

4x Pattern mode uses the Pat Rise, Pat High, Pat Fall, and Pat Low properties to store four 20 bit (max 0xfff) sub-patterns.

Frequency uses the Freq Trig Lvl, Counts High, and Counts Low properties

Waveform mode uses the bit pattern stored by the Pattern Set property.

==== Pat Rise/High/Fall/Low ====

Implimented for: longout, longin

Stores a 20-bit pattern.

==== Freq Trig Lvl ====

Implimented for: bo, bi

Synchronize forces to this level when in frequency mode.

==== Counts High/Low ====

Implimented for: longout, longin, ao, ai

Stores a value (>20) which is the number of counts (long) or time (analog) of the high or low part of a square wave.

=== Input ===

Properties in this section apply to the Input sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Input".

See: evrApp/Db/evrin.db

==== Active Level ====

Implimented for: bo, bi

When operating in level triggered mode,
determines if codes are sent when the input level is low, or high.

==== Active Edge ====

Implimented for: bo, bi

When operating in edge triggered mode,
Determines if codes are sent on the falling or rising edge in the
input signal.

==== External Mode ====

Implimented for: mbbo, mbbi

Selects the condition (Level, Edge, None) in which to inject event
codes into the local mapping ram.
These codes are treated as codes coming from the downstream event link.

==== External Code ====

Implimented for: longout, longin

Sets the code which will be applied to the local mapping ram whenever
the 'External Mode' condition is met.

==== Backwards Mode ====

Implimented for: mbbo, mbbi

Selects the condition (Level, Edge, None) in which to send on
the upstream event link.

==== Backwards Code ====

Implimented for: longout, longin

Sets the code which will be sent on the upstream event link whenever
the 'Backwards Mode' condition is met.

==== DBus Mask ====

Implimented for: mbbo, mbbi

Sets the upstream Distributed Bus bit mask which is driven by this
input.


=== Event Mapping ===

Properties in this section describe actions which should be taken when
an event code is received.

==== Pulse Generator Mapping ====

Implimented for: longout

See: evrApp/Db/evrpulsermap.db

Causes a received event to trigger
a Pulse Generator (Pulser) sub-unit, or force it into
an active (set) or inactive (reset) state.

These records will have DTYP set to "EVR Pulser Mapping".

Each record will cause one event to trigger, set, or reset one
Pulse Generator.
It is possible (and likely) that more then one record will interact
with each event code or Pulse Generator.
However, each pairing must be unique.

-------------------------------------------
record(longout, "$(P)$(N)$(M)") {
  field( DTYP, "EVR Pulser Mapping" )
  field( OUT , "@C=$(C), I=$(PID), Func=S$(F)")
  field( PINI, "YES")
  field( DESC, "Mapping for Pulser $(PID)")
  field( VAL , "$(EVT)")
  field( LOPR, "0")
  field( HOPR, "255")
}
-------------------------------------------

In this example the event '$(EVT)' in the 'VAL' field will cause
function '$(F)' on Pulse Generator '$(PID)'.
Current functions are 'Trig', 'Reset', and 'Set'.

==== Special Function Mapping ====

Implimented for: longout

See: evrApp/Db/evrmap.db

Allows a number of special actions to be mapped to certains events.
These actions include:

Blink::
  An LED on the EVRs front panel will blink when the code is received.

Forward::
  The received code will be immediately retransmits on the upstream
  event link.

Stop Log::
  Freeze the circular event log buffer.  An CPU interrupt will be
  raised which will cause the buffer to be downloaded.
  This might be a useful action to map to a fault event.

Log::
  Include this event code in the circular event log.

Heartbeat::
  This event resets the heartbeat timeout timer.

Reset PS::
  Resets the phase of all prescalers.

TS reset::
  Transfers the seconds timestamp from the shift register and zeros
  the sub-seconds part.

TS tick::
  When the timestamp source is 'Mapped code' then any event with
  this mapping will cause the sub-seconds part of the timestamp
  to increment.

Shift 1::
  Shifts the current value of the seconds timestamp shift register
  up by one bit and sets the low bit to 1.

Shift 0::
  Shifts the current value of the seconds timestamp shift register
  up by one bit and sets the low bit to 0.

FIFO::
  Bypass the automatic allocation mechanism and always include
  this code in the event FIFO.

=== Database Events ===

Implimented for: event

See: evrApp/Db/evrevent.db

A device support for the 'event' recordtype is provided which
uses the Event FIFO to record the arrival of certain interesting
events.  When set to SCAN 'I/O Intr' the event record device support
will process the record causing the requested DB event.

----------------------------------------
record(event, "$(P)$(N)") {
  field(DTYP, "EVR")
  field(SCAN, "I/O Intr")
  field(INP , "@Card=$(C),Code=$(CODE)")
  field(VAL , "$(EVNT)")
}

record(calc, "$(P)$(N):count") {
  field(SCAN, "Event")
  field(CALC, "A+1")
  field(INPA, "$(P)$(N):count NPP")
  field(EVNT, "$(EVNT)")
}
----------------------------------------

In this example the hardware event code '$(CODE)' will cause the
database event '$(EVNT)'.  Note that while both '$(CODE)' and
'$(EVNT)' are numbers, they need not be the same.  Hardware
code 21 can cause DB event 40.
