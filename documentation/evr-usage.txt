
/////////
Compile with asciidoc
http://www.methods.co.nz/asciidoc/
/////////

MRF EVR Usage Guide
===================
:Author:    Michael Davidsaver
:Email:     mdavidsaver@bnl.gov
:Date:      February 2010
:Revision:  1
:Key words: epics, ioc, device support, mrf, timing

== Overview ==

The purpose of this document is to act as a guide and reference
when using the 'mrfioc2' EPICS device support for the Micro Research
Finland (MRF) timing Event Receiver (EVR).
Usage of the Event Generator (EVG) is described elsewhere.

The MRF Event Timing System can be deployed in two configurations.
The first is a unidirectional broadcast from a single source (EVG) to multiple
destinations (EVRs).
The Repeater devices are simply retransmits the its single input to all outputs.
In the second configuration a return patch from many EVRs back up to a central
(master) EVR is added.

An EVR will act in one of two roles: either Leaf or Master.
All, or all but one, EVR will be in the Leaf role.
The special Master EVR acts as the termination point for events
and data on the upstream path.

[[mrf_overview]]
.Two system configurations for the MRF Timing System
image::images/mrf-overview.png[]

What is transmitted over the event link is a combination of 8-bit event
codes and data.
Data can take the form of a single 8-bit byte which is simply copied from sender
to receiver (Distributed Bus or DBus), and optionally a variable length byte
array (Data Buffer).

These two types of data can be combined in two ways depending on whether or not
the data buffer transmission feature is used.
In configuration A every 16-bit frame is split between an 8-bit event and
the 8-bit Distributed Bus.
In configuration B every frame carries an 8-bit event with the Distributed Bus
and Data Buffer sent in alternating frames.

In addition to data, the use of 8b10b encoding on the event link allows the
local oscillator of each EVR to be phase locked to the master on the EVG.

[[mrf_frames]]
.Two supported link allocation schemes
image::images/mrf-frames.png[]

Internally an EVR can be thought of a number of logical sub-units connected
to the up- and down- stream event links, and to the local inputs and outputs
of the EVR.
These sub-units include: the Event Mapping Ram, Pulse Generators,
Prescalers (clock dividers), and the logical controls for the physical
inputs and outputs.

[[evr_blocks]]
.Logical connections inside an EVR
image::images/mrf-evr-blocks.png[]

=== Pulse Generators ===

Each pulse generator has a an associated delay, width, and polarity
(active low/high).
When triggered by the Mapping Ram it will wait for a set time in its inactive state (delay).
Then it will transition to its active state, wait another set time (width)
before transitioning back to its inactive state.

In addition, the Mapping Ram can force a Pulse Generator into either state (Set/Reset).

=== Event Mapping Ram ===

The Event Mapping Ram is a table used to define the actions to be taken by
an EVR when it receives a certain event code number.
The mapping it defines is a many-to-many relations.
One event can cause several actions, and one action can be caused by
several events.

The actions which can be taken can be grouped into two catagories:
Special actions, and Pulse Generator actions.
Special actions include those related to timestamp distribution, and
the system heartbeat tick.
Each Pulse Generate has three mapable actions: Set, Reset, and Trigger.

=== Prescalers (Clock Divider) ===

Prescaler sub-units take the local system clock frequency and output a
lower frequency clock which is phased locked to the local clock,
which is in sync with the global master clock.
The lower frequency will be an integer multiple of the system clock.

=== Outputs ===

This sub-unit represents a local physical output on the EVR.
Each output may be connected to one source: a Distributed Bus bit,
a Prescaler, or a Pulse Generator.

=== Inputs ===

An input can cause several actions when triggered by a local signal.
It may be directly connected to one of the upstream Distributed Bus bits,
it may cause an event to be sent on the upstream links, or applied
to the local Mapping Ram.

== What is Available? ==

More infomation on the Micro Research hardware can be found on their
website http://www.mrf.fi/[http://www.mrf.fi/].

The software discussed below can be found on the EPICS application
project on SourceForge http://sourceforge.net/projects/epics/[http://sourceforge.net/projects/epics/].

The latest developments can be found in the 'mrfioc2' Mercuial VCS repository.

http://epics.hg.sourceforge.net/hgweb/epics/mrfioc2/summary[http://epics.hg.sourceforge.net/hgweb/epics/mrfioc2/summary]

=== Prerequisites ===

The only required software is EPICS Base 3.14.x, and the MSI tool.

Base: http://www.aps.anl.gov/epics/base/R3-14/index.php[http://www.aps.anl.gov/epics/base/R3-14/index.php]

MSI: http://www.aps.anl.gov/epics/extensions/msi/index.php[http://www.aps.anl.gov/epics/extensions/msi/index.php]

The Mercurial VCS tool is needed to checkout the development repository.

Mercuial: http://mercurial.selenic.com/[http://mercurial.selenic.com/]

=== The Source ===

VCS Checkout

-----------------------------------------------------------------------
$ hg checkout http://epics.hg.sourceforge.net:8000/hgroot/epics/mrfioc2
-----------------------------------------------------------------------

Edit 'configure/CONFIG_SITE' and run "make".

The following is a brief tour of the important locations in the source tree
relating to the EVR.

==== mrfCommon ====

Some support functions.  Contains 'mrfCommonIO.h' which devices macros
for access to memory mapped IO.  Also the support a library and CLI utilities
for en/decoding the control word for the fractional synthesizer used on
EVRs and EVGs.

==== pciApp ====

OS independent abstraction for working with PCI devices.

==== vmeApp ====

OS independent abstraction for working with VME64x devices.

==== evrApp ====

The MRF IOC has a strong seperation between device and driver support.
The device support and interface definition are in this module.
The interface is defined by the C++ abstract base classes in 
'evrApp/src/evr/'.
A set of device support routines using is found in 'evrApp/src/dev*.cpp'.
Some generic database files are found in 'evrApp/Db/'.

==== evrMrmApp ====

The is the device support for the Modular Register Map (MRM) firmware
version for the EVR.
It provides a concrete implimentation of the abstract classes defined
in 'evrApp'.
It also provided IOC shell function in 'evrMrmApp/src/drvemIocsh.cpp'.
'evrMrmApp/Db/evr-*.substitutions' will create a complete example
database.
An example IOC using the database is in 'iocBoot/iocevrmrm/'.

== Device Support Design ==

The EPICS device support package for EVRs consists of a number of supports
which are generally tied to a specific logical sub-unit.
Each sub-unit may be thought of as having a number of properties.
For example a Delay Generator has properties 'Delay' and 'Width'.
These properties can be set in several ways.
A delay can specified as in terms of an integer number of tick of its reference
clock (hardware view), or in seconds as a floating point number (user view).

In this example the properties 'Delay' and 'Width' should be settable in
exact integer as well as the more useful, but inexact, units of seconds.
This needs to be accomplish by two different device supports (longout,
and ao).
Of course it is also useful to have some confirmation that settings
have been applied so read-backs are desireable (longin, ai).

To this end the Pulser impliments the following device supports.

-------------------------------------------------------
# Pulser devices
# '#Lcard Apulser Cmappingram S0 @'
device(longin,     AB_IO, devLIEVRPulser, "EVR Pulser")
device(longout,    AB_IO, devLOEVRPulser, "EVR Pulser")
device(ai,         AB_IO, devAIEVRPulser, "EVR Pulser")
device(ao,         AB_IO, devAOEVRPulser, "EVR Pulser")
device(bi,         AB_IO, devBIEVRPulser, "EVR Pulser")
device(bo,         AB_IO, devBOEVRPulser, "EVR Pulser")
-------------------------------------------------------

Since the Pulser sub-unit has the property 'Delay'
which supports both integer and float settings,
the following database can be constructed.

--------------------------------------------
record(ao, "$(P)$(N)delay:set") {
  field(DTYP, "EVR Pulser")
  field(OUT , "#L$(C) A$(PID) C0 S0 @Delay")
  field(PINI, "YES")
  field(DESC, "Pulse Generator $(PID)")
  field(VAL , 0)
  field(EGU , "uSec")
  field(LINR, "LINEAR")
  field(ESLO, 1e6)
  field(PREC, 6)
  field(FLNK, "$(P)$(N)delay")
}

record(longout, "$(P)$(N)delay:set:raw") {
  field(DTYP, "EVR Pulser")
  field(OUT , "#L$(C) A$(PID) C0 S0 @Delay")
  field(FLNK, "$(P)$(N)delay")
}

record(ai, "$(P)$(N)delay") {
  field(DTYP, "EVR Pulser")
  field(INP , "#L$(C) A$(PID) C0 S0 @Delay")
  field(UDF , 0)
  field(EGU , "uSec")
  field(LINR, "LINEAR")
  field(ESLO, 1e6)
  field(PREC, 6)
  field(FLNK, "$(P)$(N)delay:raw")
}

record(longin, "$(P)$(N)delay:raw") {
  field(DTYP, "EVR Pulser")
  field(INP , "#L$(C) A$(PID) C0 S0 @Delay")
}
--------------------------------------------

This provides "raw" and "cooked" setting and readback
for the delay property.

It is generally inadvisible to have both "raw" and "cooked"
settings in a production database unless steps are taken to
synchronize them.

== Device Support Reference ==

The following sections list the properties for all sub-units
with functional descriptions.

=== Global ===

Properties in this section apply to the EVR as a whole.

Records accessing properties in this section will have DTYP
set to "EVR".

==== Enable ====

Implimented for: bo, bi

Master enable for the EVR.
If not set then very little will happen.

==== PLL Lock Status ====

Implimented for: bi

This indicates whether the phase locked loop which synchronizes
an EVR's local oscilator with the phase of the EVG's oscilator.

==== Link Status ====

Implimented for: bi

Indicates that the event link is active.
This means that the receiver sees light, that the phase is locked,
and that valid data is being received from the EVG.

==== Model ====

Implimented for: longin

The hardware model number.

==== Version ====

Implimented for: longin

The firmware version.

==== Clock ====

Implimented for: ao, ai

Frequency of an EVR's local oscilator.
This must be close enough to the EVG master oscilator
to allow the phase locked loop to lock.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.

==== Timestamp Source ====

Implimented for: longout, longin

Determines what causes the timestamp event counter to tick.
There are three possible values.

"Event clock" (0) uses an integer divisor of the EVR's local oscilator.

"Mapped code(s)" (1) increments the counter whenever certain events arrive.

"DBus 4" uses increments on the 0->1 transition of DBus bit #4.

==== Timestamp Clock ====

Implimented for: ao, ai

Specifies the rate at which the timestamp event counter will be incremented.
This determines the resolution of all timestamps.

This setting is used in conjunction with the 'Timestamp Source'.

When the timestamp source is set to "Event clock" this property
is used to compute an integer divider from the EVR's local oscilator
frequency to the given frequency.  Since this may not be exact it is
recommended to read back the actual divider setting via the
"Timestamp Prescaler" property.

In all modes this value is used to convert the timestamp event counter
values from ticks to seconds.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.

==== Timestamp Prescaler ====

Implimented for: longin

When using the "Event clock" timestamp source this will return the actual
divisor used.  In other modes it reads 0.

==== Event Clock TS Div ====

Implimented for: longin

This is an approximate divider from the event link frequency down to
1MHz.  It is used to determine the heartbeat timeout.

==== Receive Error Count ====

Implimented for: longin

Counts the number of event link errors which occur.



=== Pulse Generator ===

Properties in this section apply to the Pulse Generator (Pulser) sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Pulser".

==== Enable ====

Implimented for: bo, bi

When not set the output of the Pulse Generator will remain in its
inactive state (normally low).
It must be set before mapped actions will have any effect.

==== Polarity ====

Implimented for: bo, bi

Reverses the output polarity.
When set, changes the Pulse Generator's output from normally low
to normally high.

==== Prescaler ====

Implimented for: longout, longin

Increses the resolution of both delay and width by an integer multiple.
Determines the tick rate of the down counters used for delay and width
with respect to the EVR's local oscillator.

==== Delay ====

Implimented for: ao, longout, ai, longin

Determines the time between when the Pulse Generator is triggered
and when it changes state from inactive to active (normally low to high).

This can be given in integer ticks, or floating point seconds.
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e6 to allow user setting/reading in microseconds.

==== Width ====

Implimented for: ao, longout, ai, longin

Determines the time between when the Pulse Generator changes state
from inactive to active (normally low to high), and when it changes
back to inactive.

This can be given in integer ticks, or floating point seconds.
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e6 to allow user setting/reading in microseconds.



=== Prescaler (Clock Divider) ===

Properties in this section apply to the Prescaler sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Prescaler".

==== Divide ====

Implimented for: longout, ao, longin

Sets the integer divisor between the Event Clock and the sub-unit output.

By default the analog units are Hertz (Hz).
This can be changed with the LINR and ESLO fields.
Use ESLO of 1e-6 to allow user setting/reading in MHz.



=== Output ===

Properties in this section apply to the Output sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Output".

==== Map ====

Implimented for: longout, longin

The meaning of this value is determined by the specific implimentation used.

For the MRM implimentation the following codes are valid.

[width="25%",cols="1,5",options="header"]
|=========================
|#  |Output Source
|63 |Force High
|62 |Force Low
|42 |Prescaler (Divider) 2
|41 |Prescaler (Divider) 1
|40 |Prescaler (Divider) 0
|39 |Distributed Bus Bit 7
|38 |Distributed Bus Bit 6
|37 |Distributed Bus Bit 5
|36 |Distributed Bus Bit 4
|35 |Distributed Bus Bit 3
|34 |Distributed Bus Bit 2
|33 |Distributed Bus Bit 1
|32 |Distributed Bus Bit 0
| 9 |Pulse generator 9
| 8 |Pulse generator 8
| 7 |Pulse generator 7
| 6 |Pulse generator 6
| 5 |Pulse generator 5
| 4 |Pulse generator 4
| 3 |Pulse generator 3
| 2 |Pulse generator 2
| 1 |Pulse generator 1
| 0 |Pulse generator 0
|=========================


=== Input ===

Properties in this section apply to the Input sub-unit.

Records accessing properties in this section will have DTYP
set to "EVR Input".

==== Active Level ====

Implimented for: bo, bi

When operating in level triggered mode,
determines if codes are sent when the input level is low, or high.

==== Active Edge ====

Implimented for: bo, bi

When operating in edge triggered mode,
Determines if codes are sent on the falling or rising edge in the
input signal.

==== External Mode ====

Implimented for: mbbo, mbbi

Selects the condition (Level, Edge, None) in which to inject event
codes into the local mapping ram.
These codes are treated as codes coming from the downstream event link.

==== External Code ====

Implimented for: longout, longin

Sets the code which will be applied to the local mapping ram whenever
the 'External Mode' condition is met.

==== Backwards Mode ====

Implimented for: mbbo, mbbi

Selects the condition (Level, Edge, None) in which to send on
the upstream event link.

==== Backwards Code ====

Implimented for: longout, longin

Sets the code which will be sent on the upstream event link whenever
the 'Backwards Mode' condition is met.

==== DBus Mask ====

Implimented for: mbbo, mbbi

Sets the upstream Distributed Bus bit mask which is driven by this
input.


=== Event Mapping ===

Properties in this section describe actions which should be taken when
an event code is received.

==== Pulse Generator Mapping ====

Implimented for: longout

Causes a received event to trigger
a Pulse Generator (Pulser) sub-unit, or force it into
an active (set) or inactive (reset) state.

These records will have DTYP set to "EVR Pulser Mapping".

Each record will cause one event to trigger, set, or reset one
Pulse Generator.
It is possible (and likely) that more then one record will interact
with each event code or Pulse Generator.
However, each pairing must be unique.

-------------------------------------------
record(longout, "$(P)$(N)$(M)") {
  field( DTYP, "EVR Pulser Mapping" )
  field( OUT , "#L$(C) A$(PID) C0 S$(F) @")
  field( PINI, "YES")
  field( DESC, "Mapping for Pulser $(PID)")
  field( VAL , $(EVT))
  field( LOPR, "0")
  field( HOPR, "255")
}
-------------------------------------------

In this example the event '$(EVT)' in the 'VAL' field will cause
function '$(F)' on Pulse Generator '$(PID)'.
Current function codes are 1 (Trigger), 2 (Reset), 3 (Set), and 4 (None).

